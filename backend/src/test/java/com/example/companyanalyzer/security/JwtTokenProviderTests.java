package com.example.companyanalyzer.security;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.test.util.ReflectionTestUtils;

import javax.crypto.SecretKey;
import java.util.Arrays; // Import Arrays
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
public class JwtTokenProviderTests {

    @InjectMocks
    private JwtTokenProvider jwtTokenProvider;

    private String testSecret = "TestSecretKeyWhichIsDefinitelyLongEnoughForHS256AlgorithmTests";
    private int testExpirationMs = 3600000; // 1 hour

    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(jwtTokenProvider, "jwtSecretString", testSecret);
        ReflectionTestUtils.setField(jwtTokenProvider, "jwtExpirationInMs", testExpirationMs);
        jwtTokenProvider.init(); // Manually call init to set up the key
    }

    private Authentication createTestAuthentication(String username, String... roles) {
        List<GrantedAuthority> authorities = Arrays.stream(roles)
                                                 .map(SimpleGrantedAuthority::new)
                                                 .collect(Collectors.toList());
        UserDetails userDetails = new User(username, "password", authorities);
        return new UsernamePasswordAuthenticationToken(userDetails, "", authorities);
    }

    @Test
    void testGenerateToken() {
        Authentication authentication = createTestAuthentication("testUser", "ROLE_USER");
        String token = jwtTokenProvider.generateToken(authentication);

        assertNotNull(token);
        assertFalse(token.isEmpty());
        // Further checks could involve decoding the token (without validation) to check claims, if needed.
    }

    @Test
    void testGetUsernameFromJWT() {
        Authentication authentication = createTestAuthentication("testUser", "ROLE_USER");
        String token = jwtTokenProvider.generateToken(authentication);
        String username = jwtTokenProvider.getUsernameFromJWT(token);

        assertEquals("testUser", username);
    }

    @Test
    void testValidateToken_ValidToken() {
        Authentication authentication = createTestAuthentication("testUser", "ROLE_USER");
        String token = jwtTokenProvider.generateToken(authentication);

        assertTrue(jwtTokenProvider.validateToken(token));
    }

    @Test
    void testValidateToken_InvalidSignature() {
        Authentication authentication = createTestAuthentication("testUser", "ROLE_USER");
        String token = jwtTokenProvider.generateToken(authentication);

        // Create another provider with a different secret
        JwtTokenProvider otherProvider = new JwtTokenProvider();
        ReflectionTestUtils.setField(otherProvider, "jwtSecretString", "AnotherSecretKeyWhichIsAlsoLongEnoughForTestingPurposes");
        ReflectionTestUtils.setField(otherProvider, "jwtExpirationInMs", testExpirationMs);
        otherProvider.init();

        // Token generated by jwtTokenProvider should be invalid for otherProvider if secrets differ (which they do)
        // However, validateToken uses its own key. So, we need to tamper the token or use a token signed by a different key.
        // Let's try to validate a token signed by a different key
        SecretKey otherKey = Keys.hmacShaKeyFor("AnotherSecretKeyWhichIsAlsoLongEnoughForTestingPurposesIndeed".getBytes());
        String otherToken = Jwts.builder()
                               .setSubject("otherUser")
                               .setIssuedAt(new Date())
                               .setExpiration(new Date(System.currentTimeMillis() + testExpirationMs))
                               .signWith(otherKey, SignatureAlgorithm.HS256)
                               .compact();

        assertFalse(jwtTokenProvider.validateToken(otherToken), "Token signed with a different key should be invalid.");
    }

    @Test
    void testValidateToken_MalformedToken() {
        String malformedToken = "this.is.notajwttoken";
        assertFalse(jwtTokenProvider.validateToken(malformedToken));
    }

    @Test
    void testValidateToken_ExpiredToken() {
        // Create a token with negative expiration
        SecretKey key = Keys.hmacShaKeyFor(testSecret.getBytes());
        String expiredToken = Jwts.builder()
                                 .setSubject("testUser")
                                 .setIssuedAt(new Date(System.currentTimeMillis() - testExpirationMs * 2)) // Issued in the past
                                 .setExpiration(new Date(System.currentTimeMillis() - testExpirationMs)) // Expired an hour ago
                                 .signWith(key, SignatureAlgorithm.HS256)
                                 .compact();
        assertFalse(jwtTokenProvider.validateToken(expiredToken));
    }

    @Test
    void testValidateToken_UnsupportedToken() {
        // e.g. a token signed with a different algorithm if the parser is configured strictly
        // For this test, an empty token might be treated as unsupported or malformed by the library
        assertFalse(jwtTokenProvider.validateToken(""));
    }

    @Test
    void testValidateToken_EmptyClaims() {
        // This is tricky to generate directly, usually an empty subject or other critical claim missing
        // For now, an empty token string serves as a proxy for a JWT that might be problematic
        assertFalse(jwtTokenProvider.validateToken(""), "An empty string token should be invalid.");
    }

    @Test
    void init_ShortSecretKeyGeneratesNewKey() {
        JwtTokenProvider shortSecretProvider = new JwtTokenProvider();
        ReflectionTestUtils.setField(shortSecretProvider, "jwtSecretString", "short");
        ReflectionTestUtils.setField(shortSecretProvider, "jwtExpirationInMs", testExpirationMs);

        // Capture current key before init
        SecretKey keyBeforeInit = (SecretKey) ReflectionTestUtils.getField(shortSecretProvider, "jwtSecretKey");
        assertNull(keyBeforeInit); // Should be null before init

        shortSecretProvider.init();

        SecretKey keyAfterInit = (SecretKey) ReflectionTestUtils.getField(shortSecretProvider, "jwtSecretKey");
        assertNotNull(keyAfterInit);
        // Verify it's not derived from "short" but a new HS256 key
        assertNotEquals(Keys.hmacShaKeyFor("short".getBytes()), keyAfterInit);
    }
}
